{"code":"class TaskManager {\r\n    constructor(threshold, timeout = 20000) {\r\n        this.threshold = threshold;\r\n        this.rest = threshold; // 还能直接执行多少个task\r\n        this.readyToRun = []; // 存储等待执行的task，是一个队列，先进先出\r\n        this.result = []; // 存储已经执行返回的结果\r\n        this.timeout = timeout;\r\n        this._afterTaskCompletedChanged = this._afterTaskCompletedChanged.bind(this);\r\n        this.stopWaitingPromiseFromNow = this.stopWaitingPromiseFromNow.bind(this);\r\n        this.wakeUp = this.wakeUp.bind(this);\r\n        this._stopFromNow = false;\r\n    }\r\n    /**\r\n   * 添加任务，不能立即执行的添加到等待队列，能立即执行的直接执行，执行完成之后自动执行下一个等待任务\r\n   * @param {*} {task, timeout} task需要执行的任务，timeout为此任务的超时时间\r\n   */\r\n    addTask({ task, timeout }) {\r\n        console.log(1111111111);\r\n        if (this.rest > 0) {\r\n            return new Promise((resolve) => {\r\n                // 直接执行task，rest减少一个，this.rest表示还能直接执行几个task\r\n                this.rest--;\r\n                resolve(this._promiseWithTimeout(task, timeout));\r\n            }).then(this._afterTaskCompletedChanged, this._afterTaskCompletedChanged);\r\n        }\r\n        else {\r\n            return new Promise((resolve) => {\r\n                // 这里resolve与当前promise实例绑定\r\n                // 原理可以看promise中_resolve的实现\r\n                this.readyToRun.push({ task, resolve, timeout });\r\n            });\r\n        }\r\n    }\r\n    /**\r\n   * 用于用户暂停或者恢复等待中的task的执行\r\n   * @param {*} value\r\n   */\r\n    stopWaitingPromiseFromNow() {\r\n        this._stopFromNow = true;\r\n        return this.result;\r\n    }\r\n    /**\r\n   * 用于用户暂停或者恢复等待中的task的执行\r\n   * @param {*} value\r\n   */\r\n    wakeUp() {\r\n        if (this.rest === this.threshold && this._stopFromNow) {\r\n            this._stopFromNow = false;\r\n            this.rest--;\r\n            // 如果没有等待中的任务，那么下面的函数什么都不会做。\r\n            this._runNextTask();\r\n        }\r\n        return this.result;\r\n    }\r\n    /**\r\n   * 任务执行完成之后： 收集task执行后的结果保存到this.result中\r\n   * @param {*} value\r\n   */\r\n    _afterTaskCompletedChanged(value) {\r\n        this.result.push(value);\r\n        // 用了定时器来保证了，addTask返回的promise的then的回调先执行，然后再执行下一个等待中的task\r\n        setTimeout(this._runNextTask.bind(this), 0);\r\n        // 这里是为addTask的then回调返回value\r\n        return value;\r\n    }\r\n    /**\r\n   * 用setTimeout伪中断task\r\n   * @param {*} task\r\n   * @param {*} timeout\r\n   */\r\n    _promiseWithTimeout(task, timeout = this.timeout) {\r\n        let taskPromise, timerId = null;\r\n        if (typeof task === 'function') {\r\n            taskPromise = task();\r\n        }\r\n        else {\r\n            taskPromise = Promise.resolve(task);\r\n        }\r\n        let timeoutPromise = new Promise((resolve) => {\r\n            timerId = setTimeout(() => {\r\n                resolve('超时了');\r\n            }, timeout);\r\n        });\r\n        return Promise.race([taskPromise, timeoutPromise]).finally(() => {\r\n            clearTimeout(timerId);\r\n            timerId = null;\r\n        });\r\n    }\r\n    /**\r\n   * 内部执行器，取一个等待队列执行\r\n   */\r\n    _runNextTask() {\r\n        // task状态变化了，那么增加一个直接执行task的名额\r\n        this.rest++;\r\n        if (this._stopFromNow)\r\n            return;\r\n        // 如果等待执行的task列表不为空\r\n        if (this.readyToRun.length > 0) {\r\n            //console.log(this.readyToRun.length)\r\n            //取出队列中的一个task执行\r\n            let item = this.readyToRun.shift();\r\n            if (item) {\r\n                this.rest--;\r\n                // 在task返回的promise的状态变化之后，执行下一个task\r\n                new Promise((resolve) => {\r\n                    let { task, resolve: itemResolve, timeout } = item;\r\n                    resolve(this._promiseWithTimeout(() => {\r\n                        // 执行task\r\n                        let result = task();\r\n                        // 改变之前addTask将task添加到this.readyToRun的那个promise的状态\r\n                        itemResolve(result);\r\n                        // 必须返回result，这个由task返回的promise\r\n                        return result;\r\n                    }, timeout));\r\n                }).then(this._afterTaskCompletedChanged, this._afterTaskCompletedChanged);\r\n            }\r\n        }\r\n    }\r\n}\r\nexport default TaskManager;\r\n"}
